## 数值的整数次方

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

思路:

* 通过快速幂乘法将时间复杂度从 O(n) 降到 O(logn)

```python
def power(base, exponent):
    if base == 0:
        return 0
    if exponent == 0:
        return 1
    exp = abs(exponent)
    tmp = base
    res = 1
    while exp > 0:
        if exp & 1 == 1: # 判断二进制右边第一位是否为 1
            res *= tmp   # 为 1 则乘一个 base^(2^k)
        exp = exp >> 1   # 右移 1 位
        tmp *= tmp       # 实现 base^(2^k)
    return res if exponent > 0 else 1/res
```

### **位运算**

`Python`中位运算(位运算是对二进制的操作),

| 符号 |   作用   |
| :--: | :------: |
| `>>` |  向右移  |
| `<<` |  向左移  |
| `&`  |  按位与  |
| `|`  |  按位或  |
| `~`  |   取反   |
| `^`  | 按位异或 |

1. `>>`

对某整数二进制的原码进行右移,

例如:

* 整数 `13` 的二进制原码为 `1101`
* 那么 `13 >> 1` (`13` 的二进制原码右移一位)后,其二进制原码变成 `110` ,十进制变成 `6`, 在 `Python` 中相当于执行 `13 // 2` 

2. `<<`

对某整数二进制原码进行左移,进行左移时,右边会用 `0` 补齐

例如:

* 还是整数 `13` 
* 对其进行左移 `13 << 1` (左移一位),其二进制原码变成 `11010` ,十进制变成 `26` ,在 `Python` 中相当于 `13 * 2`

3. `&` 

按位与是对某整数二进制的单个位进行比较运算.同理于 `and` 的短路原则.

* 还是整数 `13`  ,原码 `1101`
* `13 & 1` 的意思是取 `13` 的原码 `1101` ,从右往左取第一个 `1` ,然后和 `1` 进行或运算(可以理解为 `1 and 1 ` , 根据短路原则会返回右边的 `1`, 可以判断 `&` 左边数的奇偶) 
* 如果现在对 `13` 进行右移一位( `13 >> 1`),二进制原码变成 `110`
* 这时再按位与,这时的按位与是 `0 & 1` ( `0 and 1`, 返回 `0`)

4. `|`

按位或

5. `~`

取反,这里取反是对某整数的二进制补码取反

例如:

* `~5==-6`
* 首先:正整数的原码=反码=补码
* 所以 `5` 的补码为 `0101`, 注意,在二进制中,首位表示正负号,`1` 代表负,`0` 代表正
* 补码取反为 `1010` 
* 补码转原码: 符号位不变,其他取反再加一
* `1010` 的原码为 `1110`, 对应的十进制为 `-6`

### 快速幂乘

求 `2^678` 的值

一般思路直接相乘:

`2^678 = 2 * 2 * 2 * ... * 2` 

这样实现的时间复杂度为 O(n),在计算非常大的数时运行时间将变得非常慢

通过快速幂乘将时间复杂度降为 O(logN)

```python
# 先看 2^13
# 快速幂乘是将 2^13 变成 2^(2^k)
# 2^13 = 2^(2^3)*2^(2^2)*2^(2^0)
# 先看 13 的二进制原码 1101
# 快速幂是将 13 变成 二进制再进行计算,上面的公式是下面公式简化
# 2^13 = 2^(2^3*1)*2^(2^2*1)*2^(2^1*0)*2^(2^0*1)
# 在 13 二进制原码的 1 位时会进行相乘

# 2^678
bin(678)  # 1010100110
678 = 2^9 + 2^7 + 2^5 + 2^2 + 2^1
2^678 = 2^(2^9)*2^(2^7)*2^(2^5)*2(2^2)*2(2^1)

# 结合位运算,判断指数的二进制原码中 1 的位置和个数,实现上面的公式

```

