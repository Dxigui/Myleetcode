## 数值的整数次方

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

思路:

* 通过快速幂乘法将时间复杂度从 O(n) 降到 O(logn)

```python
def power(base, exponent):
    if base == 0:
        return 0
    if exponent == 0:
        return 1
    exp = abs(exponent)
    tmp = base
    res = 1
    while exp > 0:
        if exp & 1 == 1:
            res *= tmp
        exp = exp >> 1
        tmp *= tmp
    return res if exponent > 0 else 1/res
```

**位运算**

`Python`中位运算(位运算是对二进制的操作),

| 符号 |   作用   |
| :--: | :------: |
| `>>` |  向右移  |
| `<<` |  向左移  |
| `&`  |  按位与  |
| `|`  |  按位或  |
| `~`  |   取反   |
| `^`  | 按位异或 |

1. `>>`

对某整数二进制的原码进行右移,

例如:

* 整数 `13` 的二进制原码为 `1101`
* 那么 `13 >> 1` (`13` 的二进制原码右移一位)后,其二进制原码变成 `110` ,十进制变成 `6`, 在 `Python` 中相当于执行 `13 // 2` 

2. `<<`

对某整数二进制原码进行左移,进行左移时,右边会用 `0` 补齐

例如:

* 还是整数 `13` 
* 对其进行左移 `13 << 1` (左移一位),其二进制原码变成 `11010` ,十进制变成 `26` ,在 `Python` 中相当于 `13 * 2`

3. `&` 

按位与是对某整数二进制的单个位进行比较运算.同理于 `and` 的短路原则.

* 还是整数 `13`  ,原码 `1101`
* `13 & 1` 的意思是取 `13` 的原码 `1101` ,从右往左取第一个 `1` ,然后和 `1` 进行或运算(可以理解为 `1 and 1 ` , 根据短路原则会返回右边的 `1`) 
* 如果现在对 `13` 进行右移一位( `13 >> 1`),二进制原码变成 `110`
* 这时再按位与,这时的按位与是 `0 & 1` ( `0 and 1`, 返回 `0`)

4. `|`

按位或

5. `~`

取反,这里取反是对某整数的二进制补码取反

例如:

* `~5==-6`
* 首先:正整数的原码=反码=补码
* 所以 `5` 的补码为 `0101`, 注意,在二进制中,首位表示正负号,`1` 代表负,`0` 代表正
* 补码取反为 `1010` 
* 补码转原码: 符号位不变,其他取反再加一
* `1010` 的原码为 `1110`, 对应的十进制为 `-6`

